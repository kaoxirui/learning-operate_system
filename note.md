# 信号量
## 概念
**信号量机制**是一种有效的进程同步和互斥工具。信号量有整形，记录型，二进制型信号量等。常用整型信号量实现PV操作。P操作表示申请一个资源，V操作表示释放一个资源

信号量是一种特殊的变量，表现形式为一个整型S和一个队列

**信号量取值的意义**：S>=0时，表示某资源的可用数；S<0时，其绝对值表示阻塞队列中等待该资源的进程数

**P操作**：S=S-1，若S>=0，进程继续执行；若S<0,进程暂停执行，进入等待队列。即执行P操作时，有可用资源则继续执行，无可用资源则等待

**V操作**：S=S+1，若S>0，进程继续执行；若S<=0,唤醒等待队列中的一个进程。即执行V操作时，无等待进程则继续执行；有等待进程则唤醒该进程，然后本进程继续执行

**临界资源**：一次仅允许一个进程使用的资源。多个进程必须互斥地对它进行访问。在硬件方面有打印机、传真机等，软件方面有变量、缓冲区等。

**临界区**：每个进程中访问临界资源的那一段代码。每次只允许一个进程进入临界区，进入后不允许其他进程进入。

## PV操作处理相关问题
### 进程的互斥
所谓进程的互斥，指当一个进程（线程）进入临界区使用临界资源时，需要使用临界资源的其他进程（线程）必须等待。退出临界区后，需要使用该临界资源的进程解除阻塞。互斥是进程（线程）之间的间接制约关系。

```c++
P(信号量)
    临界区
V(信号量)
```

令信号量初值为1，进程进入临界区时执行P操作，信号量变为0，此时临界资源相当于被锁定，其他进程无法访问。然后执行V操作退出临界区，信号量变为1，临界资源得到释放，其他进程可以进行访问。

### 进程的同步
进程同步是指为完成某种任务而建立的两个及两个以上的进程在某些位置上因工作次序的需要而等待、传递信息所产生的直接制约关系，这种制约关系源于他们之间的合作关系（依赖关系）。所以同步是一种更为复杂的互斥。也就是说，进程同步就是进程（线程）的运行必须严格按照某种先后次序来运行，从而完成的特定的任务。

最简单的同步形式：进程A执行到L1时，依赖于进程B执行到L2时产生的数据。当进程A执行到L1时，如果进程B还未产生相应的数据，进程A只好等待进程B，只有进程B执行到L2计算出相应的结果后线程A在接着往下运行。

```c++
进程A     进程B
...       ...
L1：P()   L2:V()
...       ...
```

设置信号量初值为0，如果进程A先执行到L1，执行P操作后信号量小于0，A等待，直到B执行到L2执行V操作后，信号量为0，唤醒A继续执行。如果进程B先执行到L2，信号量+1，则进程A无需等待，直接就可以执行完

### 生产者与消费者问题
...

## std::unique_lock
为锁管理模板类，是对mutex的封装。**std::unique_lock对象以独占所有权的方式管理mutex对象的上锁和解锁操作，即在unique_lock对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而unique_lock的声明周期结束后，他所管理的锁对象会被解锁**

```c++
#include <mutex>

std::mutex mutex;  // 创建一个互斥量

{
    std::unique_lock<std::mutex> lock(mutex);  // 对互斥量进行加锁

    // 在互斥量保护的临界区内执行一些操作
    // ...

}  // 在作用域结束时，unique_lock 的析构函数会自动解锁互斥量
```

当一个线程需要访问共享资源时，它会尝试获取锁。如果没有其他线程持有该锁，那么该线程成功获取锁，可以安全地访问共享资源。如果有其他线程已经持有锁，那么当前线程就会被阻塞，直到锁被释放。

锁的实现机制通常依赖于底层操作系统提供的原语，如互斥量、原子操作、条件变量等。具体实现细节可能因操作系统和编程语言而异。

## 条件变量

一种用于等待的同步机制，能阻塞一个或多个线程，直到收到另外一个线程发出的通知时，才会唤醒当前阻塞的线程。**与互斥量配合起来使用**

### 成员函数

`condition_variable`的成员函数主要分为两个部分：`线程等待（阻塞）函数`和`线程通知（唤醒）函数`。定义于头文件`<condition_variable>`

* 等待函数

调用wait()函数的线程会被阻塞

```c++
// ①
void wait (unique_lock<mutex>& lck);
// ②
template <class Predicate>
void wait (unique_lock<mutex>& lck, Predicate pred);
```

函数①：调用该函数的线程直接被阻塞

函数②：该函数的第二个参数是一个判断条件，是一个返回只为bool类型的函数

    该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数

    表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行


# 内存管理

* 操作系统的内存管理包括物理内存和虚拟内存管理

**物理内存管理：**包括程序装入等概念，交换技术，连续分配管理方式和非连续分配管理方式（分页，分段，段页式）

**虚拟内存管理：**包括虚拟内存概念，请求分页管理方式，页面置换算法，页面分配策略，工作集和抖动

# 死锁

**死锁**是指两个或两个以上的进程在执行过程中，由于资源竞争或由于彼此之间通信而造成的一种阻塞现象，若无外力作用，他们都无法推进下去。此时称系统处于死锁状态

* 系统资源不足
* 程序执行顺序有问题
* 资源分配不当

## 资源分级法
为每个资源分配一个唯一的等级，并且要求进程必须按照资源的等级顺序请求资源。这样，循环等待的情况就不会发生，从而预防了死锁

# 其他
## emplace_back()
用与在容器的尾部直接构造新元素，而不需要显示地进行拷贝构造或移动操作

与push_back()不同，emplace_back()允许我们将参数直接传递给元素的构造函数，从而在容器中就地构造新元素

```c++
threads.emplace_back([&fileManager](){
    //模拟并发访问文件操作
    string content=fileManager.queryFile("test.txt");
    cout<<"Thread accessed file with content:"<<content<<endl;
});
```

&fileManager:是一个lambda表达式的捕获列表，指定了要在lambda函数中使用的外部变量。在这个例子中，捕获了fileManager变量，以便在lambda表达式中使用它

[&fileManager](){...}：这是一个lambda函数，表示线程要执行的操作。lambda函数以[]包围捕获列表，后面是函数参数列表（此处为空），然后是函数体

表示引用传递捕捉变量&fileManager
